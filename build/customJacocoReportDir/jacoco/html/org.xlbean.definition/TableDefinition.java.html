<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TableDefinition.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">xlbean</a> &gt; <a href="index.source.html" class="el_package">org.xlbean.definition</a> &gt; <span class="el_source">TableDefinition.java</span></div><h1>TableDefinition.java</h1><pre class="source lang-java linenums">package org.xlbean.definition;

import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xlbean.excel.XlCellAddress;
import org.xlbean.excel.XlSheet;

/**
 * Definition for table.
 * 
 * &lt;p&gt;
 * To represent a structure of table, which is a set of pre-defined columns and
 * any number of rows, this class has a {@code attributes} property as a Map of
 * {@link SingleDefinition}s. For a column, name of the column and column number
 * is set to {@link SingleDefinition} object and set to {@code attributes}. For
 * rows, only the start row number is set to {@link SingleDefinition} object and
 * set to {@code attributes}.
 * &lt;/p&gt;
 * 
 * @author Kazuya Tanikawa
 *
 */
<span class="fc" id="L26">public class TableDefinition extends Definition {</span>

    public static final String START_MARK = &quot;~&quot;;

<span class="fc" id="L30">    private static Logger log = LoggerFactory.getLogger(TableDefinition.class);</span>

<span class="fc" id="L32">    private Map&lt;String, SingleDefinition&gt; attributes = new HashMap&lt;&gt;();</span>

    /**
     * Returns true if the direction of the table is down.
     * 
     * &lt;p&gt;
     * It returns false, which means direction is &quot;down&quot;, when this definition
     * meets either of the following conditions.
     * &lt;ul&gt;
     * &lt;li&gt;Has a option which name is &quot;direction&quot; and value is &quot;right&quot;&lt;/li&gt;
     * &lt;li&gt;&quot;~&quot; cell is defined at the top row.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     * 
     * @return
     */
    public boolean isDirectionDown() {
<span class="fc" id="L49">        String direction = getOptions().get(&quot;direction&quot;);</span>
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">        if (direction == null) {</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">            return getStartCell().getRow() != null;</span>
        } else {
<span class="nc bnc" id="L53" title="All 2 branches missed.">            return !&quot;right&quot;.equals(direction);</span>
        }
    }

    /**
     * Returns {@code attributes} which is a map to hold all the columns and
     * start cell information.
     * 
     * @return
     */
    public Map&lt;String, SingleDefinition&gt; getAttributes() {
<span class="fc" id="L64">        return attributes;</span>
    }

    /**
     * Add given {@code attributeDefinition} to this table definition.
     * 
     * @param attributeDefinition
     */
    public void addAttribute(SingleDefinition attributeDefinition) {
<span class="fc" id="L73">        attributes.put(attributeDefinition.getName(), attributeDefinition);</span>
<span class="fc" id="L74">    }</span>

    /**
     * Returns instance of {@link XlCellAddress} of start cell.
     * 
     * @return
     */
    public XlCellAddress getStartCell() {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (attributes.get(START_MARK) == null) {</span>
<span class="nc" id="L83">            return null;</span>
        }
<span class="fc" id="L85">        return attributes.get(START_MARK)</span>
<span class="fc" id="L86">                .getCell();</span>
    }

    /**
     * Merges given {@link TableDefinition} instance with this instance.
     * 
     * &lt;p&gt;
     * It iterates for all the {@code attributes} and merges them. If
     * {@code name} of the given instance and this instance is not the same, it
     * writes out {@code warn} level log.
     * &lt;/p&gt;
     * 
     * @param newDefinition
     */
    @Override
    public void merge(Definition newDefinition) {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (newDefinition.getName() == null || !newDefinition.getName()</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">                .equals(this.getName()) || !(newDefinition instanceof TableDefinition)) {</span>
<span class="nc" id="L104">            log.warn(&quot;TableDefinition {} cannot be merged to {}.&quot;, newDefinition.getName(), getName());</span>
        }
<span class="fc" id="L106">        TableDefinition definition = (TableDefinition) newDefinition;</span>
<span class="fc" id="L107">        definition.getAttributes()</span>
<span class="fc" id="L108">                .forEach((key, newColumn) -&gt; {</span>
<span class="fc" id="L109">                    SingleDefinition columnDefinition = attributes.get(key);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">                    if (columnDefinition == null) {</span>
<span class="fc" id="L111">                        attributes.put(key, newColumn);</span>
                    } else {
<span class="fc" id="L113">                        columnDefinition.merge(newColumn);</span>
                    }
<span class="fc" id="L115">                });</span>
<span class="fc" id="L116">        addOptions(definition.getOptions());</span>
<span class="fc" id="L117">    }</span>

    @Override
    public boolean validate() {
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">        return getStartCell() != null &amp;&amp; attributes.size() &gt; 0;</span>
    }

    @Override
    public void setSheet(XlSheet sheet) {
<span class="fc" id="L126">        super.setSheet(sheet);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (SingleDefinition attr : getAttributes().values()) {</span>
<span class="fc" id="L128">            attr.setSheet(sheet);</span>
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">    }</span>

    @Override
    public void setSheetName(String sheetName) {
<span class="fc" id="L134">        super.setSheetName(sheetName);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (SingleDefinition attr : getAttributes().values()) {</span>
<span class="fc" id="L136">            attr.setSheetName(sheetName);</span>
<span class="fc" id="L137">        }</span>
<span class="fc" id="L138">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L142">        return &quot;TableDefinition [attributes=&quot; + attributes + &quot;]&quot;;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>