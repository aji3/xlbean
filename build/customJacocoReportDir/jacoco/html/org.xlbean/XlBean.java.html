<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>XlBean.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">xlbean</a> &gt; <a href="index.source.html" class="el_package">org.xlbean</a> &gt; <span class="el_source">XlBean.java</span></div><h1>XlBean.java</h1><pre class="source lang-java linenums">package org.xlbean;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.xlbean.converter.BeanConverter;
import org.xlbean.util.XlBeanFactory;

/**
 * Data store class.
 * 
 * &lt;p&gt;
 * Basic concept of this library is to read or write any value on excel sheet as
 * {@link String}. This class is to hold this string value with it's name as
 * map. Although type of value is always {@link String}, to express general data
 * structure of Java object, Map or List is used to realize it so that Map and
 * List are also candidate of value of this map.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * This class extends {@link HashMap&lt;String, Object&gt;} and overrides
 * {@link #put(String, Object)} to limit types of object it can hold. This class
 * can have following classes as value of map.
 * &lt;ul&gt;
 * &lt;li&gt;{@link XlBean}&lt;/li&gt;
 * &lt;li&gt;{@link XlList}&lt;/li&gt;
 * &lt;li&gt;{@link SingleValue}&lt;/li&gt;
 * &lt;li&gt;{@link String}&lt;/li&gt;
 * &lt;/ul&gt;
 * However, you usually do not have to care what object can be put or not
 * because there is {@link #set(Object)} method which converts any type of
 * object, including Map, List and any other custom classes, to XlBean suitable
 * type.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Other methods defined in this class are utility to convert {@link Map} to
 * other format easily.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Although the type of value is {@link Object}, only three types of objects are
 * potentially put to the bean. The three types are {@link XlBean},
 * {@link XlList} and {@link String}
 * &lt;/p&gt;
 * 
 * @author Kazuya Tanikawa
 */
@SuppressWarnings(&quot;serial&quot;)
<span class="fc" id="L51">public class XlBean extends HashMap&lt;String, Object&gt; {</span>

    /**
     * Convert this {@link XlBean} object to {@link XlList} object with elements
     * belongs to a List retrieved by {@code extractFieldName} and put all the
     * key-values in this object to each element inside the List.
     * 
     * &lt;p&gt;
     * This is an inverse method for {@link XlList#aggregate(String, String...)}
     * .
     * &lt;/p&gt;
     * 
     * @param extractFieldName
     * @return
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public XlList extract(String extractFieldName) {
<span class="nc" id="L68">        XlList extractedTable = XlBeanFactory.getInstance()</span>
<span class="nc" id="L69">                .createList();</span>
<span class="nc" id="L70">        Object extractField = this.get(extractFieldName);</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        if (Iterable.class.isAssignableFrom(extractField.getClass())) {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">            for (XlBean extractRow : (Iterable&lt;XlBean&gt;) extractField) {</span>
<span class="nc" id="L73">                putAllExcept(this, extractRow, extractFieldName);</span>
<span class="nc" id="L74">                extractedTable.add(extractRow);</span>
<span class="nc" id="L75">            }</span>
        } else {
<span class="nc" id="L77">            extractedTable.add(this);</span>
        }
<span class="nc" id="L79">        return extractedTable;</span>
    }

    /**
     * Overridden method of {@link HashMap#put(Object, Object)} with type check
     * added.
     * 
     * &lt;p&gt;
     * This method allows only the following types:
     * &lt;ul&gt;
     * &lt;li&gt;{@link XlBean}&lt;/li&gt;
     * &lt;li&gt;{@link XlList}&lt;/li&gt;
     * &lt;li&gt;{@link SingleValue}&lt;/li&gt;
     * &lt;li&gt;{@link String}&lt;/li&gt; If the value type is other than above, then
     * {@link IllegalArgumentException} will be thrown.
     * &lt;/ul&gt;
     * 
     * &lt;/p&gt;
     * 
     * @throws IllegalArgumentException
     *             If value type doesn't match allowed type.
     */
    @Override
    public Object put(String key, Object value) {
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (!canPut(value)) {</span>
<span class="nc" id="L104">            throw new IllegalArgumentException(String.format(</span>
                    &quot;Value set to XlBean must be XlBean, XlList or String. To set value of any other class to this bean, please use #set(Object). set(Object) will scan all the properties in the object and set to this object.&quot;,
<span class="nc" id="L106">                    value.getClass()));</span>
        }
<span class="fc" id="L108">        return super.put(key, value);</span>
    }
    
    protected boolean canPut(Object value) {
<span class="pc bpc" id="L112" title="1 of 8 branches missed.">        return !(value != null &amp;&amp; !(value instanceof XlBean || value instanceof XlList || value instanceof String));</span>
    }

    private void putAllExcept(XlBean src, XlBean dst, String excludeFieldName) {
<span class="nc" id="L116">        src.forEach((key, value) -&gt; {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (key.equals(excludeFieldName)) {</span>
<span class="nc" id="L118">                return;</span>
            }
<span class="nc" id="L120">            dst.put(key, value);</span>
<span class="nc" id="L121">        });</span>
<span class="nc" id="L122">    }</span>

    public XlBean bean(String key) {
<span class="nc" id="L125">        return (XlBean) get(key);</span>
    }

    public XlList list(String key) {
<span class="fc" id="L129">        return (XlList) get(key);</span>
    }

    /**
     * Returns the object retrieved by {@code key} after casting to generic
     * type.
     * 
     * &lt;p&gt;
     * This method will not check type before casting so make sure that the
     * object is able to be casted to specified type.
     * &lt;/p&gt;
     * 
     * @param key
     * @return
     */
    public String value(String key) {
<span class="fc" id="L145">        Object ret = get(key);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (ret == null) {</span>
<span class="fc" id="L147">            return null;</span>
        } else {
<span class="fc" id="L149">            return ret.toString();</span>
        }
    }

<span class="fc" id="L153">    private static BeanConverter converter = new BeanConverter();</span>

    public static void updateConverter(BeanConverter converter) {
<span class="nc" id="L156">        XlBean.converter = converter;</span>
<span class="nc" id="L157">    }</span>

    /**
     * Returns the object of {@code destinationClass} filled with the contents
     * mapped from this {@link XlBean} instance.
     * 
     * @param destinationClass
     * @return
     */
    public &lt;T&gt; T of(Class&lt;?&gt; destinationClass) {
<span class="fc" id="L167">        return converter.toBean(this, destinationClass);</span>
    }

    /**
     * Returns the object of {@code destinationClass} filled with the contents
     * mapped from a {@code Map} retrieved by {@code sourceKey}.
     * 
     * &lt;p&gt;
     * If an object retrieved by {@code sourceKey} is null or not {@code Map}
     * instance, then it returns blank instance of {@code destinationClass}.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Mapping from {@code Map} of {@code sourceKey} to instance of
     * {@code destinationClass} is key to property mapping. Refer to
     * {@link BeanConverter} for further detail.
     * &lt;/p&gt;
     * 
     * @param sourceKey
     * @param destinationClazz
     * @return
     */
    public &lt;T&gt; T beanOf(String sourceKey, Class&lt;?&gt; destinationClass) {
<span class="nc" id="L190">        Object srcObj = get(sourceKey);</span>
<span class="nc" id="L191">        return converter.toBean(srcObj, destinationClass);</span>
    }

    /**
     * Returns the list of {@code beanClass} instances filled with the contents
     * mapped from beans in the list which are retrieved by {@code sourceKey}
     * from this {@code BaseMap} instance.
     * 
     * @param sourceKey
     * @param beanClass
     * @return
     */
    public &lt;T&gt; List&lt;T&gt; listOf(String sourceKey, Class&lt;?&gt; beanClass) {
<span class="nc" id="L204">        Object srcList = get(sourceKey);</span>
<span class="nc" id="L205">        return converter.toBeanList(srcList, beanClass);</span>
    }

    public void set(Object obj) {
<span class="nc" id="L209">        Object convertedObj = converter.toMap(obj);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (convertedObj instanceof XlBean) {</span>
<span class="nc" id="L211">            putAll((XlBean) convertedObj);</span>
        }
<span class="nc" id="L213">    }</span>

    public void set(Object obj, String key) {
<span class="fc" id="L216">        Object convertedObj = converter.toMap(obj);</span>
<span class="fc" id="L217">        put(key, convertedObj);</span>
<span class="fc" id="L218">    }</span>

    public boolean isValuesEmpty() {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (Object item : this.values()) {</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (item == null) {</span>
<span class="nc" id="L223">                continue;</span>
            }
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">            if (item instanceof String &amp;&amp; !((String) item).isEmpty()) {</span>
<span class="fc" id="L226">                return false;</span>
<span class="pc bpc" id="L227" title="3 of 4 branches missed.">            } else if (item instanceof XlList &amp;&amp; ((XlList) item).size() != 0) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                for (XlBean obj : (XlList) item) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                    if (!obj.isValuesEmpty()) {</span>
<span class="nc" id="L230">                        return false;</span>
                    }
<span class="nc" id="L232">                }</span>
            }
<span class="fc" id="L234">        }</span>
<span class="fc" id="L235">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>